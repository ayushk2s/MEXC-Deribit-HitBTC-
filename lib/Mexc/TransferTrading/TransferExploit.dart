import 'dart:convert';
import 'package:arbitrage_trading/Mexc/TradingCodes/PriceDifferenceTrading.dart';
import 'package:http/http.dart' as http;
import 'dart:async';
import 'package:crypto/crypto.dart';

const apiKey = 'mx0vglyapIN01W6cTN';
const secretKey = '34c726b4c3004369bc45be1a50181bd9';
const String baseUrl = 'https://api.mexc.com/api/v3';
void main() async {
  DateTime now = DateTime.now();

 try{

   final perpetualPair = 'XRP_USDT';
   final spotPair = 'XRP_USDT';

   GetMexcAssetPrice getMexcAssetPrice = GetMexcAssetPrice();
   final perpetualPrice = await getMexcAssetPrice.fetchPerpetualPrice(perpetualPair);
   final spotPrice = await getMexcAssetPrice.fetchSpotPrice(spotPair);

   print('Spot Price: $spotPrice');
   print('Perpetual Price: $perpetualPrice');
   print('Price Difference: ${spotPrice-perpetualPrice}');

   final symbol = 'XRP_USDT'; // Replace with the desired trading pair
   final leverage = 1; // 1x leverage
   final quantity = 1.0; // Quantity of the contract
   final price = 0.5; // Replace with your target price
   final orderType = 'limit'; // Order type: 'limit' or 'market'

   // await placeFuturesOrder(apiKey, secretKey, symbol, leverage, quantity, price, orderType);

   await placeSpotOrder('XRPUSDT', '$spotPrice', '50');
   await transferFromFuturesToSpot('XRP', 1.0);

   // Timer.periodic(const Duration(seconds: 1), (timer) async {
   //   try {
   //     final perpetualPrice = await retry(() => fetchPerpetualPrice(perpetualPair));
   //     final spotPrice = await retry(() => fetchSpotPrice(spotPair));
   //     final priceDifference = spotPrice - perpetualPrice;
   //
   //     print('Spot Price: $spotPrice');
   //     print('Perpetual Price: $perpetualPrice');
   //     print('Price Difference: $priceDifference');
   //     print('-----------------------------------------------------------------');
   //   } catch (e) {
   //     print('Error: $e');
   //   }
   // });

 }finally{
   DateTime end = DateTime.now();
   print('${end.difference(now)}');
   print('-------------------------------------');
   main();
 }
}

/// Retry a function `fn` up to [retries] times with a delay between attempts.
Future<T> retry<T>(
    Future<T> Function() fn, {
      int retries = 3,
      Duration delay = const Duration(milliseconds: 500),
    }) async {
  for (int attempt = 0; attempt < retries; attempt++) {
    try {
      return await fn();
    } catch (e) {
      if (attempt == retries - 1) {
        rethrow; // Rethrow the error after final attempt
      }
      await Future.delayed(delay);
    }
  }
  throw Exception('Retries exhausted'); // Should not reach here
}



///Trading Codes Spot
Future<void> placeSpotOrder(String symbol, String price, String quantity) async {
  const apiKey = 'mx0vglyapIN01W6cTN';
  const secretKey = '34c726b4c3004369bc45be1a50181bd9';
  const endpoint = 'https://api.mexc.com/api/v3/order';

  final timestamp = DateTime.now().millisecondsSinceEpoch.toString();
  const recvWindow = '5000';

  final params = {
    'symbol': symbol,
    'side': 'BUY',
    'type': 'LIMIT',
    'price': price,
    'quantity': quantity,
    'recvWindow': recvWindow,
    'timestamp': timestamp,
  };

  final sortedParams = params.entries.map((e) {
    final key = Uri.encodeComponent(e.key);
    final value = Uri.encodeComponent(e.value);
    return '$key=$value';
  }).join('&');

  final signature = generateSignature(secretKey, sortedParams);
  final url = '$endpoint?$sortedParams&signature=$signature';

  final headers = {
    'X-MEXC-APIKEY': apiKey,
    'Content-Type': 'application/json',
  };

  try {
    final response = await http.post(
      Uri.parse(url),
      headers: headers,
    );

    if (response.statusCode == 200) {
      final data = jsonDecode(response.body);
      print('Spot order placed successfully: $data');
    } else {
      print('Failed to place Spot order. Status: ${response.statusCode}, Body: ${response.body}');
    }
  } catch (e) {
    print('Error: $e');
  }
}

String generateSignature(String secretKey, String totalParams) {
  final hmac = Hmac(sha256, utf8.encode(secretKey));
  final digest = hmac.convert(utf8.encode(totalParams));
  return digest.toString().toLowerCase(); // Signature must be lowercase
}


///Trading code futures
Future<void> placeFuturesOrder(
    String apiKey,
    String apiSecret,
    String symbol,
    int leverage,
    double quantity,
    double price,
    String orderType,
    ) async {
  final String url = 'https://contract.mexc.com/api/v1/contract/order';

  // Create the request body
  final Map<String, dynamic> body = {
    'symbol': symbol,
    'leverage': leverage,
    'quantity': quantity,
    'price': price,
    'orderType': orderType,
    'side': 'buy', // 'buy' for long, 'sell' for short
    'positionMode': 'cross', // Or 'isolated' based on your preference
    'timestamp': DateTime.now().millisecondsSinceEpoch,
  };

  // Convert body to query string for signature
  final String queryString = mapToQueryString(body);

  // Generate signature
  final String signature = generateSignature(apiSecret, queryString);

  // Add signature to the body
  body['signature'] = signature;

  final headers = {
    'Content-Type': 'application/json',
    'X-MEXC-APIKEY': apiKey,
  };

  // Send POST request
  final response = await http.post(
    Uri.parse(url),
    headers: headers,
    body: jsonEncode(body),
  );

  if (response.statusCode == 200) {
    final data = jsonDecode(response.body);
    print('Response data: $data');
    if (data['code'] == 200) {
      print('Order successfully placed: ${data['data']}');
    } else {
      throw Exception('Error placing order: ${data['msg']}');
    }
  } else {
    print('Response status: ${response.statusCode}');
    print('Response body: ${response.body}');
    throw Exception('HTTP Error: ${response.statusCode}');
  }
}
/// Converts a Map to a query string
String mapToQueryString(Map<String, dynamic> map) {
  final List<String> queryParams = [];
  map.forEach((key, value) {
    queryParams.add('${Uri.encodeComponent(key)}=${Uri.encodeComponent(value.toString())}');
  });
  queryParams.sort(); // Sort the parameters alphabetically
  return queryParams.join('&');
}

///Trading codes Transfering

Future<void> transferFromFuturesToSpot(String asset, double amount) async {
  // Current timestamp in milliseconds
  final timestamp = DateTime.now().millisecondsSinceEpoch.toString();

  // Build the query parameters
  final queryParams = {
    'api_key': apiKey,
    'fromAccountType': 'FUTURES',
    'toAccountType': 'SPOT',
    'asset': asset,
    'amount': amount.toString(),
    'timestamp': timestamp,
  };

  // Prepare the total params string to create the signature
  final totalParams = queryParams.entries.map((e) => '${e.key}=${e.value}').join('&');

  // Generate the signature
  final signature = generateSignature(secretKey, totalParams);

  // Add signature to the query parameters
  final url = Uri.parse('$baseUrl/capital/transfer?$totalParams&signature=$signature');

  print(url);
  // Send the POST request to the MEXC API
  final response = await http.post(url);

  if (response.statusCode == 200) {
    print('Transfer Successful: ${response.body}');
  } else {
    print('Error: ${response.body}');
  }
}


