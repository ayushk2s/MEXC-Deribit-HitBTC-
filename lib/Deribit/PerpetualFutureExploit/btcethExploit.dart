import 'dart:convert';
import 'package:http/http.dart' as http;
import 'dart:async';

void main() async {
  double walletBalance = 40.0; // Virtual wallet
  double btcBuyPrice = 0;
  double ethSellPrice = 0;
  bool isTradeActive = false;

  Future<void> tradeLoop() async {
    final btcPerpetualPair = 'BTC-PERPETUAL';
    final ethPerpetualPair = 'ETH-PERPETUAL';

    try {
      final btcPerpetualPriceData = await fetchOrderBook(btcPerpetualPair);
      final ethPerpetualPriceData = await fetchOrderBook(ethPerpetualPair);

      final btcBidPrice = btcPerpetualPriceData['nearestBid']['price'];
      final ethAskPrice = ethPerpetualPriceData['nearestAsk']['price'];

      print('BTC Bid Price: $btcBidPrice');
      print('ETH Ask Price: $ethAskPrice');

      // Assuming a $20 investment for both
      final btcQuantity = 20 / btcBidPrice;
      final ethQuantity = 20 / ethAskPrice;

      if (!isTradeActive) {
        // Execute the trade
        btcBuyPrice = btcBidPrice; // Selling BTC at bid
        ethSellPrice = ethAskPrice; // Buying ETH at ask
        isTradeActive = true;

        print('Trade initiated:');
        print('Sold BTC at $btcBuyPrice for $btcQuantity BTC');
        print('Bought ETH at $ethSellPrice for $ethQuantity ETH');
      } else {
        // Calculate potential P&L
        final btcCurrentAskPrice = btcPerpetualPriceData['nearestAsk']['price'];
        final ethCurrentBidPrice = ethPerpetualPriceData['nearestBid']['price'];

        final btcPnl = (btcCurrentAskPrice - btcBuyPrice) * btcQuantity;
        final ethPnl = (ethSellPrice - ethCurrentBidPrice) * ethQuantity;
        final totalPnl = btcPnl + ethPnl;

        print('BTC Current Ask Price: $btcCurrentAskPrice');
        print('ETH Current Bid Price: $ethCurrentBidPrice');
        print('P&L: BTC = $btcPnl, ETH = $ethPnl, Total = $totalPnl');

        if (totalPnl > 0) {
          walletBalance += totalPnl; // Add profit to the wallet
          print('Trade closed with profit: $totalPnl');
          print('Updated Wallet Balance: $walletBalance');
          isTradeActive = false; // Reset the trade state
        }
      }

      print('-----------------------------------------------------------------');
    } catch (e) {
      print('Error: $e');
    }

    Future.delayed(const Duration(seconds: 3), tradeLoop);
  }

  tradeLoop();
}

Future<Map<String, dynamic>> fetchOrderBook(String instrumentName) async {
  final String url = "https://www.deribit.com/api/v2/public/get_order_book";
  final Map<String, String> params = {'instrument_name': instrumentName};

  try {
    final Uri uri = Uri.parse(url).replace(queryParameters: params);
    final http.Response response = await http.get(uri);

    if (response.statusCode == 200) {
      final Map<String, dynamic> data = jsonDecode(response.body);

      if (data.containsKey('result') && data['result'] != null) {
        final result = data['result'];

        final double markPrice = result['mark_price'];

        // Nearest bid and ask
        final nearestBid = {
          'price': result['bids'][0][0],
          'amount': result['bids'][0][1],
        };
        final nearestAsk = {
          'price': result['asks'][0][0],
          'amount': result['asks'][0][1],
        };

        return {
          'markPrice': markPrice,
          'nearestBid': nearestBid,
          'nearestAsk': nearestAsk,
        };
      } else {
        throw Exception('No data available for the instrument.');
      }
    } else {
      throw Exception('Error: HTTP ${response.statusCode}');
    }
  } catch (e) {
    throw Exception('Error fetching data: $e');
  }
}
